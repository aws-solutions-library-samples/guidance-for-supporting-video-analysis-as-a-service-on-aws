use crate::message::MqttMessage;

use super::client_settings::AsyncIotClientSettings;
use super::error::ClientError;

use device_traits::connections::{PubSubClient, PubSubMessage, QoS as AWSQoS};

use anyhow::anyhow;
use async_trait::async_trait;
use leaky_bucket::RateLimiter;

use rumqttc::{
    AsyncClient, ConnAck, ConnectionError, Event, EventLoop, Outgoing, Packet, QoS, SubAck,
    SubscribeReasonCode,
};
use tokio::sync::mpsc;
use tokio::sync::mpsc::error::TrySendError;
use tokio::task::JoinHandle;
use tracing::{error, info, instrument, trace, warn};

use std::time::Duration;

use std::collections::HashMap;
use std::fmt::Formatter;

const MAX_PAYLOAD_SIZE_IN_BYTES: usize = 128000;
const MAX_MQTT_EVENT_QUEUE_SIZE: usize = 2048;
const NUM_OF_TOKENS_TO_ADD_AT_EACH_INTERVAL: usize = 1;
const TIME_DURATION_BETWEEN_ADD_REFILL_TO_LIMITER: Duration = Duration::from_millis(5000);
const MAX_NUMBER_TOKENS: usize = 5;
const INIT_NUM_TOKENS: usize = 2;

/// the async mqtt client for AWS IoT
pub struct MqttClient {
    /// Rumqttc async client employed as our async mqtt client
    async_client: AsyncClient,
    /// Rumqttc event loop where we send and receive Mqtt message
    event_loop_task: JoinHandle<()>,
    /// Receiver for mqtt events generated by running the event_loop_task.
    event_rx: mpsc::Receiver<Result<Event, ConnectionError>>,
    /// Saved subcriptions so that they can be used for the re-sub when recovering from disconnection.
    topics_subscribed_to: HashMap<String, QoS>,
}

impl std::fmt::Debug for MqttClient {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Mqtt client subscribed to: {:?}", self.topics_subscribed_to)
    }
}

impl Drop for MqttClient {
    fn drop(&mut self) {
        self.event_loop_task.abort();
    }
}

impl MqttClient {
    /// Initialize a new `MqttClient` for AWS IoT
    #[instrument]
    pub async fn new(aws_settings: &AsyncIotClientSettings) -> Result<Self, ClientError> {
        let mqtt_options = aws_settings.generate_aws_mqtt_options()?;
        let (async_client, event_loop) = AsyncClient::new(mqtt_options, MAX_MQTT_EVENT_QUEUE_SIZE);
        let (event_tx, event_rx) = mpsc::channel(MAX_MQTT_EVENT_QUEUE_SIZE);
        let event_loop_task = tokio::spawn(Self::run_event_loop(event_loop, event_tx));

        info!("New Mqtt Client Created.");

        Ok(MqttClient {
            async_client,
            event_loop_task,
            event_rx,
            topics_subscribed_to: HashMap::new(),
        })
    }
    /// Getter function for the write part of Mqtt client
    pub fn get_async_client(&self) -> AsyncClient {
        self.async_client.clone()
    }

    /// Submit a Mqtt publish message to the event loop.
    /// Success here does not mean a successful publish to IoT, rather it pushed to
    /// the event loop successfully.
    pub async fn publish<Ta, Tb>(
        &self,
        topic: Ta,
        qos: QoS,
        retain: bool,
        payload: Tb,
    ) -> Result<(), ClientError>
    where
        Ta: Into<String>,
        Tb: Into<Vec<u8>>,
    {
        // check due to the limited QoS support currently provided by AWS IoT
        if self.if_qos_invalid_for_aws_iot(qos) {
            return Err(ClientError::AWSIoTQoSError);
        }
        self.async_client.publish(topic, qos, retain, payload).await?;
        Ok(())
    }

    /// Used in MessageReciever trait, Receive a message from a subscribed topic.
    pub async fn recv_mqtt_event(&mut self) -> Result<Event, ConnectionError> {
        match self.event_rx.recv().await {
            Some(event) => event,
            None => {
                // The reason to panic here vs. return an error is that the event loop task must
                // have exited and dropped the Sender to this receiver for us to get a None
                // response. At that point, the event loop won't be running and the
                // async client will never make any progress again.
                // We could try to restart the event loop here at that point, but doing so could
                // be problematic as the event loop should never have exited unless the receiver
                // was dropped first. We are biasing towards a panic with the
                // expectation that the caller will either catch the panic and re-initialize the
                // client, or they will abort the process and restart it (recommended).
                panic!("MQTT poll loop exited unexpectedly and no more events will be available")
            }
        }
    }

    /// Monitor the ongoing event in eventloop
    ///
    /// we inherit and leverage the reconnection mechanism in rumqttc:
    /// <https://docs.rs/rumqttc/latest/rumqttc/struct.EventLoop.html#method.poll>
    ///
    /// In brief, whenever the poll() failed (i.e. emit ConnectionError) at whichever case in the select!.
    /// the clean() function will be invoked then purge the old connection state.
    /// When the next time the eventloop is polled again,
    /// the new connection will be forced to create (i.e. reconnect)
    async fn run_event_loop(
        mut event_loop: EventLoop,
        events: mpsc::Sender<Result<Event, ConnectionError>>,
    ) {
        let rate_limiter = RateLimiter::builder()
            .max(MAX_NUMBER_TOKENS)
            .initial(INIT_NUM_TOKENS)
            .interval(TIME_DURATION_BETWEEN_ADD_REFILL_TO_LIMITER)
            .refill(NUM_OF_TOKENS_TO_ADD_AT_EACH_INTERVAL)
            .build();
        // Important: do not block in this method on anything other than the event loop.
        // We need to keep calling poll() to drive the client state machine internally,
        // so if a method blocks anywhere below, the mqtt client won't be responsive.
        loop {
            // If we run into ConnectionErrors while polling the eventLoop, the caller should
            // reset the MQTT Client state to ensure that it doesn't stuck in a bad loop.
            //
            let event = event_loop.poll().await;
            if event.is_err() {
                error!("Failed to poll mqtt client eventloop due to: {:?}", event);
                warn!("Throttling back mqtt event loop polling rate due to connection due to broker connection error");
                // In the event of a connection error, throttle back the polling until
                // recovery so we don't spin up our CPU or create a DOS to the broker.
                rate_limiter.acquire_one().await;
            }
            match events.try_send(event) {
                Ok(()) => (),
                Err(TrySendError::Closed(_)) => {
                    info!(
                        "Mqtt Client dropped event queue receiver. Exiting mqtt client poll loop."
                    );
                    break;
                }
                Err(TrySendError::Full(event)) => {
                    error!("Mqtt Client event receiver queue is full. Event from mqtt broker will be dropped: {:?}", event);
                }
            };
        }
    }

    /// AWS IoT currently only supports QoS0 (At most once) and QoS1 (At least once)
    /// more info, check: <https://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html>
    /// Guard exists for publish method in this crate.
    fn if_qos_invalid_for_aws_iot(&self, qos: QoS) -> bool {
        qos == QoS::ExactlyOnce
    }
}

#[async_trait]
impl PubSubClient for MqttClient {
    async fn send(&self, message: Box<dyn PubSubMessage + Send + Sync>) -> anyhow::Result<()> {
        //Guard to confirm that if payload is too large then message will not be published
        if message.get_payload().len() > MAX_PAYLOAD_SIZE_IN_BYTES {
            return Err(anyhow::Error::new(ClientError::InvalidMessageForPublish(format!(
                "Payload too large for publish.  Size is : {} and max size is : {}",
                message.get_payload().len(),
                MAX_PAYLOAD_SIZE_IN_BYTES
            ))));
        }

        let topic = message.get_topic();
        let qos = MqttMessage::aws_qos_to_rumqttc_qos(message.get_qos());
        let retain = message.get_retain();
        let payload = message.get_payload().to_owned();

        info!("Message published to IoT with topic : {}", topic);

        self.publish(topic, qos, retain, payload).await.map_err(anyhow::Error::new)
    }

    async fn subscribe(&mut self, topic: &str, qos: AWSQoS) -> anyhow::Result<()> {
        let qos = match qos {
            AWSQoS::AtMostOnce => rumqttc::QoS::AtMostOnce,
            AWSQoS::AtLeastOnce => rumqttc::QoS::AtLeastOnce,
        };

        self.async_client.subscribe(topic, qos).await?;
        // save the topic just subscribed to re-subscribe if the persistent session with the broker
        // is lost.
        self.topics_subscribed_to.insert(topic.to_string(), qos);
        Ok(())
    }

    async fn unsubscribe(&mut self, topic: &str) -> anyhow::Result<()> {
        self.async_client.unsubscribe(topic).await?;
        self.topics_subscribed_to.remove(topic);
        Ok(())
    }

    // Loops until it receives an incoming message on a subscribed topic.
    #[instrument]
    async fn recv(&mut self) -> anyhow::Result<Box<dyn PubSubMessage + Send + Sync>> {
        loop {
            match self.recv_mqtt_event().await {
                Ok(Event::Outgoing(Outgoing::Subscribe(pkid))) => {
                    info!("Outgoing subscribe: pkid {}", pkid);
                }
                Ok(Event::Outgoing(message)) => {
                    trace!("Outgoing message from mqttc event loop: {:?}", message);
                }
                Ok(Event::Incoming(message)) => match message {
                    Packet::Publish(msg_from_broker) => {
                        trace!("Received incoming message from broker: {:?}", msg_from_broker);
                        // It is valid for a PUBLISH packet to contain a zero length payload.
                        // See: http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718040
                        if msg_from_broker.payload.is_empty() {
                            warn!("Received a zero length message from the broker");
                            continue;
                        }

                        // consider using flat_message buffers https://crates.io/crates/flatbuffers
                        return match std::str::from_utf8(&msg_from_broker.payload[..]) {
                            Ok(s) => {
                                let message = MqttMessage {
                                    topic: msg_from_broker.topic,
                                    qos: msg_from_broker.qos,
                                    payload: String::from(s),
                                    retain: msg_from_broker.retain,
                                };
                                Ok(Box::new(message))
                            }
                            Err(e) => {
                                Err(anyhow!("Unable to parse message from broker as a String: {:?}, message: {:?}",
                                        e, msg_from_broker))
                            }
                        };
                    }

                    Packet::ConnAck(ConnAck { session_present, code }) => {
                        if !session_present {
                            info!("No persistent session present with broker. Re-subscribing to topics (could be empty if none were subscribed to yet): {:?}", self.topics_subscribed_to);
                            for (topic, qos) in &self.topics_subscribed_to {
                                self.async_client.subscribe(topic.clone(), *qos)
                                    .await
                                    .expect("Mqtt event loop dropped recv end of channel for subscriptions and a subscribe will never succeed");
                            }
                        }
                        info!("connack: session_present {}, code: {:?}", session_present, code);
                    }
                    Packet::SubAck(SubAck { pkid, return_codes }) => {
                        info!(
                            "Suback received from MQTT broker: pkid {}, return codes: {:?}",
                            pkid, return_codes
                        );
                        // We just log the failure here.
                        if return_codes.iter().any(|&code| code == SubscribeReasonCode::Failure) {
                            error!("Error returned in SubAck for pkid: {}", pkid);
                        }
                    }
                    _ => {
                        trace!("Received incoming message from broker: {:?}", message);
                    }
                },
                Err(e) => {
                    error!("Connection error with broker: {:?}", e);
                }
            }
        }
    }
}

#[cfg(test)]
///Unit tests for mqttclient.  Tests which involve communication with the mqtt broker are
/// in the tests folder.
mod tests {
    use super::*;
    use device_traits::connections::MockPubSubMessage;
    use tokio::time::Duration;

    use crate::client_settings::AsyncIotClientSettings;
    const PORT: u16 = 1234;
    const CLIENT_ID: &str = "Client ID";
    const ENDPOINT: &str = "Doesnt Matter";
    const TEST_PAYLOAD: &str = "{\"string\":\"Hello World!\"}";
    const TEST_TOPIC: &str = "topic/does/not/matter";
    #[tokio::test]
    /// This tests the debug formatter for our mqtt client.
    async fn mqtt_debug() {
        let mqtt_client = create_mqtt_client_for_unit_tests().await;
        assert_eq!(format!("{mqtt_client:?}"), "Mqtt client subscribed to: {}");
    }

    #[tokio::test]
    /// This tests if we can get the internal rumqttc client we are using.
    /// This test will fail if it doesnt get an object of correct type.
    async fn mqtt_get_rumqttc_client() {
        let mqtt_client = create_mqtt_client_for_unit_tests().await;
        let _rumqttc_client: AsyncClient = mqtt_client.get_async_client();
    }
    #[tokio::test]
    /// Should fail to publish since QoS::Exactly once is not supported.
    async fn invalid_qos_publish() {
        let mqtt_client = create_mqtt_client_for_unit_tests().await;
        let result = mqtt_client.publish(TEST_TOPIC, QoS::ExactlyOnce, false, TEST_PAYLOAD).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn payload_to_large_for_publish() {
        // Create a string that is too large.
        let payload = String::from_utf8(vec![b'X'; MAX_PAYLOAD_SIZE_IN_BYTES + 1]).unwrap();

        let mut mock_pub_sub_message = Box::new(MockPubSubMessage::new());
        // Setup Mock Message, only payload is checked.
        let _ = mock_pub_sub_message.expect_get_payload().times(2).return_const(payload);

        let mqtt_client = create_mqtt_client_for_unit_tests().await;
        let result = mqtt_client.send(mock_pub_sub_message).await;
        assert!(result.is_err());
    }

    /// Setup a mqtt client for unit tests.
    async fn create_mqtt_client_for_unit_tests() -> MqttClient {
        let client_settings = AsyncIotClientSettings::new(
            CLIENT_ID,
            None,
            ENDPOINT,
            None,
            Duration::from_secs(5),
            PORT,
        );

        MqttClient::new(&client_settings).await.unwrap()
    }
}
